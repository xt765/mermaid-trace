"""
FastAPI Integration Module for MermaidTrace.

This module provides the middleware necessary to integrate MermaidTrace with
FastAPI applications. It serves as the bridge between HTTP requests and the
sequence diagram generation logic.

Key functionalities include:
- Middleware for intercepting all incoming HTTP requests.
- Automatic extraction of tracing headers (X-Source, X-Trace-ID).
- Initialization of logging context for request lifecycles.
- Automatic logging of request start and response completion (success or error).
"""

from typing import Any, TYPE_CHECKING
import time
import uuid
import traceback

from ..core.events import FlowEvent
from ..core.context import LogContext
from ..core.decorators import get_flow_logger

# Conditional imports to support optional FastAPI dependency
if TYPE_CHECKING:
    # For static type checkers (mypy, pyright), import the actual types.
    from fastapi import Request, Response
    from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
else:
    try:
        # Runtime import attempt for FastAPI and Starlette.
        from fastapi import Request, Response
        from starlette.middleware.base import (
            BaseHTTPMiddleware,
            RequestResponseEndpoint,
        )
    except ImportError:
        # Fallback for when FastAPI is not installed in the environment.
        # This prevents ImportErrors when importing this module without FastAPI.
        # However, instantiating the middleware will still fail.
        BaseHTTPMiddleware = object  # type: ignore[misc,assignment]
        Request = Any  # type: ignore[assignment]
        Response = Any  # type: ignore[assignment]
        RequestResponseEndpoint = Any  # type: ignore[assignment]


class MermaidTraceMiddleware(BaseHTTPMiddleware):
    """
    FastAPI Middleware to trace HTTP requests as interactions in the sequence diagram.

    This middleware wraps the entire request processing pipeline. It is responsible for
    recording the initial interaction between an external client (Source) and this
    service (Target).

    Middleware Logic:
    1.  **Request Interception**: Captures the request before it reaches any route handler.
    2.  **Context Initialization**: Sets up the `LogContext` with the current service name
        and trace ID, ensuring all internal function calls are correctly associated.
    3.  **Event Logging**: Logs the "Request" event (Client -> API) and the corresponding
        "Response" event (API -> Client).
    4.  **Error Handling**: Captures exceptions, logs error events (API --x Client),
        and re-raises them to standard error handlers.

    Attributes:
        app_name (str): The name of the current service/application. This name will
                        appear as a participant in the generated Mermaid sequence diagram.
    """

    def __init__(self, app: Any, app_name: str = "FastAPI"):
        """
        Initialize the middleware.

        Args:
            app (Any): The FastAPI application instance.
            app_name (str): The name of this service to appear in the diagram (e.g., "UserAPI").
                            Defaults to "FastAPI".

        Raises:
            ImportError: If FastAPI or Starlette is not installed in the current environment.
        """
        # Validate that the necessary dependencies are present.
        if BaseHTTPMiddleware is object:  # type: ignore[comparison-overlap]
            raise ImportError(
                "FastAPI/Starlette is required to use MermaidTraceMiddleware"
            )

        # Initialize the base class.
        super().__init__(app)
        self.app_name = app_name

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        """
        Dispatch method to handle the incoming request.

        This is the core logic of the middleware. It wraps the `call_next` execution
        with tracing logic.

        Request Tracing & Header Handling:
        - **X-Source**: Used to identify the caller. If present, the diagram will show
          an arrow from `X-Source` to `app_name`. If missing, defaults to "Client".
        - **X-Trace-ID**: Used for distributed tracing. If provided, it links this
          request to an existing trace. If missing, a new UUID is generated.

        Args:
            request (Request): The incoming HTTP request object.
            call_next (RequestResponseEndpoint): A callable that invokes the next
                                                 middleware or the route handler.

        Returns:
            Response: The HTTP response generated by the application.
        """
        # ----------------------------------------------------------------------
        # 1. Header Handling and Metadata Extraction
        # ----------------------------------------------------------------------

        # Determine the source participant (Who is calling us?).
        # If the request comes from another service traced by MermaidTrace,
        # it might include the 'X-Source' header.
        source = request.headers.get("X-Source", "Client")

        # Determine the unique Trace ID.
        # This ID is critical for grouping all logs related to a single request flow.
        trace_id = request.headers.get("X-Trace-ID") or str(uuid.uuid4())

        # Define the action name for the diagram arrow.
        # Format: "METHOD /path" (e.g., "GET /api/v1/users")
        action = f"{request.method} {request.url.path}"

        # Get the configured logger for flow events.
        logger = get_flow_logger()

        # ----------------------------------------------------------------------
        # 2. Log Request Start (Source -> App)
        # ----------------------------------------------------------------------

        # Create the 'Request' event representing the call coming into this service.
        req_event = FlowEvent(
            source=source,
            target=self.app_name,
            action=action,
            message=action,
            # Include query parameters in the note if they exist.
            params=f"query={request.query_params}" if request.query_params else None,
            trace_id=trace_id,
        )

        # Log the event. This writes the JSON entry that the visualizer will parse.
        logger.info(
            f"{source}->{self.app_name}: {action}", extra={"flow_event": req_event}
        )

        # ----------------------------------------------------------------------
        # 3. Context Setup and Request Processing
        # ----------------------------------------------------------------------

        # Initialize the LogContext for this async task.
        # Any 'traced' function called within this block will inherit 'trace_id'
        # and see 'participant' as self.app_name.
        async with LogContext.ascope(
            {"participant": self.app_name, "trace_id": trace_id}
        ):
            start_time = time.time()
            try:
                # Process the request by calling the next item in the middleware chain.
                response = await call_next(request)

                # ------------------------------------------------------------------
                # 4. Log Success Response (App -> Source)
                # ------------------------------------------------------------------

                # Calculate execution time for performance insights.
                duration = (time.time() - start_time) * 1000

                # Create the 'Return' event (dashed line back to caller).
                resp_event = FlowEvent(
                    source=self.app_name,
                    target=source,
                    action=action,
                    message="Return",
                    is_return=True,
                    result=f"{response.status_code} ({duration:.1f}ms)",
                    trace_id=trace_id,
                )
                logger.info(
                    f"{self.app_name}->{source}: Return",
                    extra={"flow_event": resp_event},
                )
                return response

            except Exception as e:
                # ------------------------------------------------------------------
                # 5. Log Error Response (App --x Source)
                # ------------------------------------------------------------------

                # Capture full stack trace for the error.
                stack_trace = "".join(
                    traceback.format_exception(type(e), e, e.__traceback__)
                )

                # If an unhandled exception occurs, log it as an error event.
                # This will render as a cross (X) on the sequence diagram return arrow.
                err_event = FlowEvent(
                    source=self.app_name,
                    target=source,
                    action=action,
                    message=str(e),
                    is_return=True,
                    is_error=True,
                    error_message=str(e),
                    stack_trace=stack_trace,
                    trace_id=trace_id,
                )
                logger.error(
                    f"{self.app_name}-x{source}: Error", extra={"flow_event": err_event}
                )

                # Re-raise the exception so FastAPI's exception handlers can take over.
                # We strictly monitor the flow here, not swallow errors.
                raise
